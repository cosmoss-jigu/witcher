## Implementation of trace verification

In the simplest case, the generated trace would contain 5 operations:
* 3 logging operations that are automatically generated by PMTest:
	* `Assign(&A, sizeof(A))`: The value of A is modified by a value assignment, so the address range of A is touched.
	* `Flush(&A, sizeof(A))`:	The value of A is flushed into memory, so the address range of A is persisted.
	* `Fence()`: The fence operation which ensures that the operations happen before this fence is executed. More specifically the operations before this fence are ensured to be executed before the operations after this fence.
* 2 query operations that are inserted by user. By inserting operations at certain positions, the user will know:
	* `Persist(&A, sizeof(A))`: Is the address range of A is persisted in memory?
	* `Order(&A, sizeof(A), &B, sizeof(B))`: Is the address range of A modified strictly earlier than address range of B in memory, e.g. they are seperated by a fence?

For example, for an integer A, the address range of A is an interval like `[0x7ffe523ac210, 0x7ffe523ac214)`, but for an user defined structure, the address range may be larger. To identify the order of modification, we update the *timestamp* for each address after each modification.

Because the overhead of storing each address and corresponding timestamp is not acceptable, to support `Persist` and `Order` queries, we need a data structure that efficiently stores *intervals*, and the related *timestamp* of intervals.

We adopt a data structure named **interval tree**, which takes up O(n \* log n) space and supports the following operations in O(log n) time:
* Add an interval;
* Remove an interval;
* Given an interval x, find if x overlaps with any of the existing intervals.

This data structure is implemented in boost library.

We maintain 2 interval trees: (Note that we can only make sure an operation is executed by adding a `Fence` after it.)
* A *persistence-check* tree, that stores all address ranges that are modified but not yet flushed to memory. So we
	* Add address interval A to it after we make sure that `Assign(&A, sizeof(A))` is executed;
	* Remove address interval A from it after we make sure that `Flush(&A, sizeof(A))` is executed.
* An *order-check* tree, that stores address ranges and the latest time the address range is modified in memory, represented by the *timestamp*.
So we
	* Maintain a global variable timestamp, and initialize it to 0;
	* Increase the timestamp by one after `Fence()`;
	* After `Assign(&A, sizeof(A))` is executed, the timestamp of A is indefinitive, but shall be no less than current timestamp;
	* After `Flush(&A, sizeof(A))` is executed, the timestamp of A is definitive, which is the current timestamp.

A `fence` will ensure that every operations that appear before it in program order will be executed before it in execution order, while the execution order of operations that are not separated by a `fence` cannot be enforced by the program order. We use *timestamp* to reflect the possible *execution time* of operations, thus sections that are seperated by a `fence` will have different timestamps, while the same section will have the same timestamp, as shown below:
```
... // section where timestamp = T - 3
Fence()
... // section where timestamp = T - 2
Fence()
... // section where timestamp = T - 1
Fence()
... // section where timestamp = T, last section that is not followed by a fence
```

Recall that the main purpose of having timestamp is to determine the *execution time* of operations, and deduce the orders of them. So we firstly go over the operation trace and divide them into sections with fences. Each section will have a single timestamp. Then, we characterize each operations as follows:
* `Assign(&A, sizeof(A))` in section of timestamp T means that address A will be written to memory some time ≥ T. So we mark timestamp(A) ≥ T to address A.
* `Flush(&A, sizeof(A))` in section of timestamp T (except the last section) ensures that address A will be written to memory at time T. So we mark timestamp(A) = T to address A. If `Flush` exists in the last section that is not followed by a fence, we are not sure about the execution time of this `Flush`, so we will not update the timestamp of address A in this case.

By defining the *timestamp* of each address, we know the most recent time an address is possibly modified in memory. Then if the timestamp of A is strictly smaller than B, then the return value of `Order(&A, sizeof(A), &B, sizeof(B))` shall be true, otherwise false. More specifically:
* If timestamp(A) = T, timestamp(B) = T, timestamp(A) is not strictly smaller than timestamp(B);
* If timestamp(A) = T, timestamp(B) = T + 1, timestamp(A) is strictly smaller than timestamp(B);
* If timestamp(A) = T, timestamp(B) ≥ T + 1, timestamp(A) is strictly smaller than timestamp(B);
* If timestamp(A) ≥ T, timestamp(B) = T + 1, timestamp(A) is not strictly smaller than timestamp(B);
* If timestamp(A) ≥ T, timestamp(B) ≥ T + 1, timestamp(A) is not strictly smaller than timestamp(B).



### Examples of interval tree:
* Add address `[18, 34)` to the *persistence-check* tree:
```
Existing |---------|    |--------------|  |-----|
         10        20   25             40 43    49

Add              |---------------|
                 18              34

Result   |-----------------------------|  |-----|
         10                            40 43    49
```

* Add address `[18, 34)` with timestamp ≥ 2 to the *order-check* tree:
```
             t=0              t=1           t=1
Existing |---------|    |--------------|  |-----|
         10        20   25             40 43    49

                        t≥2
Add              |---------------|
                 18              34

            t=0         t≥2        t=1      t=1
Result   |-------|---------------|-----|  |-----|
         10      18              34    40 43    49
```
### Examples of transactions and queries:
```
Assign(&A, 4)
Fence()
Assign(&B, 4)
Flush(&A, 4)
Persist(&A, 4)		// == false
Order(&A, 4, &B, 4)	// == false
```
```
Assign(&A, 4)
Fence()
Assign(&B, 4)
Assign(&A, 4)
Flush(&A, 4)
Fence()
Persist(&A, 4)		// == true
Order(&A, 4, &B, 4)	// == false
```
```
Assign(&A, 4)
Assign(&B, 4)
Fence()
Assign(&B, 4)
Persist(&B, 4)		// == false
Order(&A, 4, &B, 4)	// == false
```


## Run PMFS with mysql server:
in `whisper/PMFS-new`:
```shell
sudo ./init.sh
```
in `pmtest`:
```shell
./build/apps/pmtest_kernel_client
```
in `mysql-5.7.6-m16-linux-glibc2.5-x86_64`:
```shell
sudo ./mysql_init.sh
sudo ./mysql_run.sh
```
You may `Ctrl-C` after executing this command and bring MySQL to background.
```shell
./sysbench_init.sh
```
```
./sysbench_complex.sh
``` 
or 
```
./sysbench_simple.sh
```
```shell
./mysql_shutdown.sh
```
The password is empty.
in `whisper/PMFS-new`:
```shell
umount /mnt/pmfs
```